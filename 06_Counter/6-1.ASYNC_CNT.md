# COUNTER - Asynchronous Counter
---

<br>

- **비동기식 카운터**

앞에서 설명한 것과 같이 J-K 플립플롭은 J와 K에 High의 값이 연결되면, 클럭이 발생할 때마다 출력 상태가 현재 출력되는 값의 반대로 바뀌게 된다. 

이러한 특징을 이용하여 클럭입력에 대한 출력의 결과는 클럭의 1/2 주파수를 갖도록 된다. 

다음 그림은 이 J-K 플립플롭을 통한 주파수 분할에 대한 논리 회로를 나타낸 것이다. 

3개의 J-K 플립플롭이 사용된 카운터로 3비트 2진 카운터라고 한다. 

<br>

<img src="./pds/ac01.png" alt="p03" style="width: 80%;">

<br>

Q0 플립플롭에서 발생한 출력 결과를 Q1 플립플롭의 클럭 입력에 연결하고, Q1 플립플롭의 결과를 Q2 플립플롭의 클럭 입력에 연결하여 각각이 2분주 되도록 회로가 구성되어 있다. 

Q0 플립플롭에 연결되는 클럭은 외부의 입력이며, 위에서 사용한 플립플롭은 클럭의 Rising Edge에 동작한다.

위의 논리 회로의 결과는 다음과 같다. 

<img src="./pds/ac02.png" alt="p02" style="width: 90%;">

<br>


위의 파형에서 알 수 있듯이 외부의 클럭 입력 주기를 tCLK라고 할 때, Q0의 출력 결과의 주기 tQ0는 tCLK의 2배의 길이를 갖는다. 이것은 주파수가 1/2인 것을 의미한다. 

Q1과 Q2의 결과도 전 플립플롭의 1/2 주파수를 갖는 파형이 발생하는 것을 알 수 있다. /

<br>

즉, N개의 플립플롭을 사용하면 최종 플립플롭의 출력 주파수는 입력 주파수의 1 / 2N 과 같다. 

이러한 플립플롭의 응용 방법을 주파수 분할이라 한다. 

<br>
주파수를 발생시키는 기기인 오실레이터는 그 출력 주파수가 많이 있지만, 모든 사용자의 조건을 맞추지 못하기 때문에, 위와 같은 주파수 분할 방법을 사용하여 시스템에서 사용하고자 하는 주파수를 생성하여야 한다.

위의 논리 회로는 주파수 분할 기능뿐만 아니라 2진 카운터로도 동작한다. 

<br>

다음 표는 위의 결과를 표로 나타낸 것이다. 

다음의 결과를 살펴보면 클럭이 발생 할 때마다 1씩 더해 지는 3비트 2진 카운터로 구성되는 것을 알 수 있다. 


<br>

|CLOCK||Q2|Q1|Q0||BCD|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|clock||0|0|0||0|
|clock||0|0|1||1|
|clock||0|1|0||2|
|clock||0|1|1||3|
|clock||1|0|0||4|
|clock||1|0|1||5|
|clock||1|1|0||6|
|clock||1|1|1||7|
|clock||0|0|0||0|
|clock||0|0|1||1|

<br>

위의 동작을 다시 설명하면 다음과 같다. 

- 3개의 J-K 플립플롭의 J와 K 입력 단자에는 모두 High의 값이 연결되어 있다. 

- 클럭의 입력은 플립플롭 Q0의 CLK 단자에만 연결이 된다. 그러므로 Q0의 결과는 클럭의 Falling Edge때마다 반전된다. 

- 플립플롭 Q0의 출력 결과는 플립플롭 Q1의 CLK 단자에 연결된다. 그래서 Q0의 출력이 1에서 0으로 변할 때마다 플립플롭 Q1의 결과는 반전될 것이다. 마찬가지로 Q1의 값이 1에서 0으로 변할 때마다 플립플롭 Q2의 결과는 반전될 것이다. 

- 플립플롭의 출력 Q2, Q1, Q0의 값이 2진수를 나타낸다고 가정하면, 위의 출력 파형은 클럭이 발생할 때마다 000에서 111까지 연속적인 2진수 계수 값을 나타내는 것을 알 수 있다. 

- 이 플립플롭의 값이 111이고, 다시 클럭이 발생하면 플립플롭 Q0의 값은 1에서 0으로 바뀐다. 이것은 플립플롭 Q1의 값을 1에서 0으로 바뀌게 하며, Q2의 값도 1에서 0으로 바뀌게 한다. 즉 카운터의 값이 111에서 000으로 바뀐다. 그리고, 다시 클럭이 발생하면 카운터는 새로운 계수의 시작될 것이다. 

<br>
 
위와 같이 각각의 플립플롭의 출력이 다음 플립플롭의 CLK 입력으로 인가되는 형태의 카운터를 비동기식 카운터(asynchronous counter)라고 한다. 

그 이유는 모든 플립플롭이 클럭 입력과 정확하기 동기되어 변하지 않기 때문이며, 클럭에 동기되어 변하는 플립플롭은 오직 Q0뿐이다. 

<br>

모든 논리 회로에서는 회로 내에서 동작을 처리하기 위한 전달 지연이 생긴다. 

기술이 발전 됨에 따라 이 전달 지연 시간이 수 ns(10-9초)로 상당히 빨라 졌지만, 완전히 없어지지는 않았다. 

플립플롭도 마찬가지로 보통 5 - 20ns정도의 전달 지연 시간을 갖고 있다. 위의 파형에서는 지연시간을 표시하지 않았지만, 실제로 하드웨어에서는 이 지연시간이 발생하며, 빠른 속도를 요하는 시스템의 경우 이러한 지연시간 때문에 오동작을 일으킬 수 있다. 

이러한 카운터를 보통 리플 카운터(ripple counter)라고 하며, 비동기식 카운터와 같은 의미로 사용된다. 


리플 카운터는 주어진 계수 동작을 하기 위해 최소한의 회로 소자로 구성할 수 있기 때문에 가장 간단한 2진 카운터의 형태이다. 하지만 이 카운터의 기본적인 동작 원리인 각각의 플립플롭은 앞 단의 플립플롭의 출력 값이 변화할 때 동작한다는 부분에서 문제가 생길 수 있다. 

먼저 플립플롭의 전달 지연 시간을 td라고 하고, 여러 개의 플립플롭이 사용되는 리플 카운터를 Design하였다고 하였을 때, 첫 번째 플립플롭에서의 지연 시간은 td만큼 걸린다. 

하지만, 점점 플립플롭의 단계를 지날수록 즉 N번째의 플립플롭에서는 N x td의 지연시간이 걸리기 때문에 문제가 될 수 있다.

<br>

3비트 리플 카운터가 Design되었고, 플립플롭의 지연시간은 40ns, 클럭의 주기를 1000ns라고 가정하면 다음의 왼쪽 그림과 같은 결과를 확인할 수 있다. 

최대 지연시간인 120ns는 클럭 주기의 1000ns에 비해 상당히 작기 때문에 리플 카운터의 동작에 영향을 미치지 않기 때문에 문제가 되지 않는다. 

하지만 높은 주파수의 클럭이 인가 된다면 다음의 오른쪽 그림과 같이 큰 문제가 될 수 있다. 

다음의 오른쪽 그림은 클럭 주기가 100ns일 때이며 이때의 동작을 살펴보면, 지연시간 때문에 5번째 클럭에서 원하는 동작이 되지 않는 것을 확인할 수 있다. 


<img src="./pds/ac02a.png" alt="p02a" style="width: 90%;">

<br>


---
## **Practice Objectives **

다음의 회로를 Design하여 실험해 보자.

<br>

<img src="./pds/ac03.png" alt="p03" style="width: 80%;">


<br>


<br>

SACT 장비에서 확인하기 위하여 연결된 장치는 다음과 같다. 

|CLK|Q2|Q1|Q0|
|:---:|:---:|:---:|:---:|
|SW7|LED7|LED6|LED5|

<br>

<img src="./pds/sact-ac.png" alt="sact-ac" style="width: 60%;">

<br>


### **Design**

1. 실험을 위해 프로젝트 파일 <a href="./pds/ASYNC_CNT.zip" download>ASYNC_CNT.zip</a>을 준비한다. 
<br>

2. 다운로드된 프로젝트의 압축 파일을 d:\work 이동시킨 후, 압축을 푼다.

3. Quartus II를 실행키고, File> Open Project 메뉴를 선택한다. 

<br>

4. 위에서 압축을 푼 위치인, d:\work\ASYNC_CNT 폴더로 이동 후,ASYNC_CNT 프로젝트를 OPEN한다. 

<br>

5. File > Open 메뉴를 선택하여 ASYNC_CNT.bdf 파일을 불러오거나, 프로젝트 왼쪽의 ASYNC_CNT 부분을 마우스로 더블 클릭한다. 

<br>

6. 아래 그림과 같이 미완성된 도면이 보이는데, Practice Objectives에서 설명한 도면으로 완성시키자. 

<img src="./pds/ac05.png" alt="p05" style="width: 80%;"><br>

<img src="./pds/ac03.png" alt="p01" style="width: 80%;"><br>

7. jkff 심볼을 불러오고, wire로 심볼을 연결시켜 회로를 완성시킨다.  

<img src="./pds/ac06.png" alt="p08" style="width: 100%;"><br>

<br>


### **Compile**


8. File > Save 메뉴를 선택하여 저장하고, Processing > Start Compilation 메뉴를 선택하여 Compile을 진행한다. 

이 Compile 과정은 Design한 논리 회로에 오류가 없는 지를 검증하고, 프로그래밍 파일과 Simulation 파일을 만드는 과정이다. 

<br><br>


### **Simulation**

9. Compile 완료 후, File > Open 메뉴를 선택하고, 나타나는 Open File 창에서 오른쪽 아래 부분의 File Type을 All File(*.*)로 변경한 후, Waveform.vwf 파일을 선택한다. 

10. 아래 그림과 같이 Waveform 창에서, Simulation > Run Functiona Simulation 메뉴를 선택하여 Functional Simulation을 진행하여, 결과를 확인한다. 

<img src="./pds/ex10.png" alt="p11" style="width: 70%;"><br>

<img src="./pds/ac08.png" alt="p10" style="width: 100%;"><br>
<br>

### **Check Hardware Operation**

11. SACT 장비를 준비한다. USB 케이블과 파워 케이블을 연결하고, 전원 스위치를 눌러 장비에 전원을 인가시킨다. 

12. Quartus 소프트웨어에서 Tool > Programmer 메뉴를 선택한다.

13. Programmer창의 Hardware Setup이 USB Blaster가 연결되어 있는지 확인하고, Start 버튼을 눌러 프로그래밍 하고 장비에서 동작을 확인한다. 

<br>

14. 버튼 스위치와 슬라이드 스위치를 동작시키고, LED에서 결과를 확인해 보자. 


SACT 장비에서 확인하기 위하여 연결된 장치는 다음과 같다. 

|CLK|Q2|Q1|Q0|
|:---:|:---:|:---:|:---:|
|SW7|LED7|LED6|LED5|

<br>